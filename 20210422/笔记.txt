1.冯诺依曼体系结构
        
        CPU和输入设备或输出设备之间不能直接交互，必须依靠中间的存储部分

内存   VS   硬盘
       1.内存的读写速度远远大于磁盘，内存的读写速度是纳秒级，硬盘的读写速度的是微秒级
       2.内存的价格远大于硬盘
       3.内存中的数据不能持久化，重启之后就没了，而磁盘可以持久化
进程：
一个执行的任务就是一个进程
可执行任务！=进程
PID是进程的身份ID，但重启之后PID就变了
进程的本质：
PCB：进程管理模块
    1.PID  主键id，身份标识
    2.状态信息（就绪，运行，阻塞，终止）
    3.优先级
    4.记账信息（防止CPU资源分配不均）
    5.一组指针（需要使用的资源）
    6.上下文（当分配到CPU资源时执行，没有资源之后暂时保存自己当前的状态，等待下一次执行，这个过程叫一个上下文）

 程序运行：
    并发：只有一个资源，轮流执行就叫并发
    并行：所有的应用一起运行
无论是从宏观还是从微观的层面都是一起执行的
多个进程不能共享资源
线程是系统调度资源的最小单位
线程是进程执行的最小单位，也是进程执行的实际单位

进程是系统分配资源的最小单位，线程是系统调度的最小单位

进程不可以共享资源，而线程可以
线程可以共享的资源
    1.打开的文件
    2.内存（对象）

线程不可以共享的资源
	上下文  记账信息  状态不能共享  线程栈信息  优先级

注意：线程的数量并不是越多越好，当线程的数量达到某个合适的值是最好的，有太多的线程就会出现线程之间的争抢cpu，
而CPU调度是需要消耗系统资源的，所以不是越多越好。

那么多少线程是最好的？
答：要看具体的应用场景，密集的CPU任务，IO型任务。当使用的场景是计算型任务时，线程的数量=CPU的数量是最好的
	IO型任务理论上线程数量越多越好

进程  VS   线程
1.进程是系统分配资源的最小单位，线程是系统调度的最小单位
2.一个进程中至少要包含一个线程
3.线程必须要依附于进程，线程是进程实质工作调度的最小单位

线程分类：1.后台线程【守护线程】  2.用户线程【默认线程】
守护线程是用来服务用户线程，没有用户线程运行进程就会结束

守护线程使用场景：Java垃圾回收器
注意事项：1.守护线程设置必须在调用start（）前，如果在之后设置不会生效，还会报错
	2.在守护线程里面创建的线程，默认情况全都是守护线程

start 和 run之间的区别：
	1.run属于普通方法，而start属于启动线程的方法
	2.run方法可以执行多次，而start只能执行一次

线程中断：
    1.使用全局自定义的变量来终止线程（在拿到终止指令之后，需要执行完当前的任务才会真正的停止线程）
    2.使用线程提供的终止方法 interrupt来终止线程

interrupted()   和  isInterruped() 
interrupted() 判断当前线程的中断标志位是否设置，调用后清除标志位
 isInterruped() 判断对象关联的线程的标志位是否设置，调用后不清除标志位

线程非安全：
	1.cpu抢占执行
	2.非原子性
	3.编译器优化（代码优化，在单线程下没问题，但在多线程下就会出现混乱）
	4.内存不可见性
	5.多个线程修改了同一个变量
解决线程安全的方案：
	1.synchronized
	2.lock
volatile的作用：
	1.禁止指令重排序
	2.解决内存不可见性的问题（实现原理：当操作完变量后，强制删除线程工作内存中的此变量）
synchronized注意事项：
在进行枷锁操作的时候，同一组业务一定是同一个锁对象
volatile和synchronized的区别：
   volatile可以解决内存可见性问题和禁止指令重排，但不能解决原子性问题
   synchronized是用来保证线程安全，也就是可以解决任何关于线程安全的问题
（关键代码排队执行，始终只有一个线程会执行加锁、原子性问题、。。。。）
synchronized和lock的区别：
  1.synchronized既可以修饰代码块又可以修饰静态方法或普通方法，而lock只能修饰代码块
  2.synchronized只有非公平锁的锁策略，而lock既可以是非公平锁的锁策略也可使是公平锁的锁策略
  3.Reentrantlock更加的灵活
  4.synchronized是自动加锁和释放锁的，而lock需要自己手动加锁和释放锁
synchronized实现的原理：
  从操作系统来说：互斥锁
  从JVM来说：帮我们实现了监视器的加锁和解锁操作
  从JAVA来说：锁对象 锁存放在变量的对象头
synchronized的优化：（四种状态）
  无锁、偏向锁、轻量级锁、重量级锁
线程的状态：
	new（新建状态）
	runnable（执行状态）{running、ready}
	waiting（等待状态）
	timed-waiting（超时等待状态）有明确结束等待时间的sleep方法
	blocked（阻塞状态）  当拿到锁之后会进入runnable状态
	timinated（终止状态）
死锁：
    定义：在多线程编程中，因为资源抢占而造成线程无限等待
造成死锁的四个条件（同时满足）：
    1.互斥条件（一个资源只能被一个线程持有）
    2.请求拥有条件（当拥有有一个资源之后试图请求另外一个资源）
    3.不可剥夺条件（一个资源在被线程拥有之后，不能被其他线程剥夺）
    4.环路等待条件（多个线程在获取资源的时候形成了一个环形链）
解决死锁可以通过修改请求的顺序

线程的通讯机制：一个线程的动作可以让另外一个线程感知到
    wait（休眠）/notify（唤醒）/notifyall（唤醒全部）
wait为什么要加锁？
    答：wait在使用的时候需要释放锁，释放之前必须有一把锁
wait为什么要释放锁？
    答：wait默认是不传值的，当不传递任何值的时候表示永久等待，这样会造成一把锁被一个线程一直持有
 wait（休眠）/notify（唤醒）/notifyall（唤醒全部）使用注意事项：
    1.使用时必须加锁
    2.加锁对象和 wait/notify/notifyall的对象必须保持一致
    3.一组wait/notify/notifyall的对象必须保持一致
Thread.sleep(0) 和 wait(0)的区别
    1.sleep他是Thread的静态方法，而wait是object的方法
    2.sleep(0)立即触发一次CPU的资源抢占，wait(0)则永久等待下去
wait和sleep的区别
相同点：1.都可以让当前线程休眠
              2.都必须要处理一个Interrupt异常
不同点：1.wait来自object中的一个方法，而sleep来自thread
	2.传参不同，wait可以没有参数而sleep必须有一个大于0的参数
	3.wait使用时必须加锁，sleep使用时不用加锁
	4.wait使用时会释放锁，而sleep不会释放
	5.wait默认不传参的情况会进入waiting状态，而sleep会进入timed-waiting
为什么wait放在object而不是Thread中
答：wait必须要加锁和释放锁，而锁是属于对象级别的而非线程级别
（线程和锁是一对多的关系，也就是一个线程可以拥有多把锁）
  为了灵活起见，就把wait放在object当中

Locksupport.park()  也可以进行线程休眠
LockSupport.unpark(线程名);    唤醒

Locksupport.park() 和lock.wait()的区别
    相同点：1.都可以休眠
	2.都可以传参或者不传参，并且二者的线程状态也是一样的
    不同点：1.wait必须加锁，而Locksupport.park不需要加锁
	2.wait只能唤醒全部或随机的一个线程，而Locksupport.park可以唤醒指定的线程
