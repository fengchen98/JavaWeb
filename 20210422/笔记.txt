1.冯诺依曼体系结构
        
        CPU和输入设备或输出设备之间不能直接交互，必须依靠中间的存储部分

内存   VS   硬盘
       1.内存的读写速度远远大于磁盘，内存的读写速度是纳秒级，硬盘的读写速度的是微秒级
       2.内存的价格远大于硬盘
       3.内存中的数据不能持久化，重启之后就没了，而磁盘可以持久化
进程：
一个执行的任务就是一个进程
可执行任务！=进程
PID是进程的身份ID，但重启之后PID就变了
进程的本质：
PCB：进程管理模块
    1.PID  主键id，身份标识
    2.状态信息（就绪，运行，阻塞，终止）
    3.优先级
    4.记账信息（防止CPU资源分配不均）
    5.一组指针（需要使用的资源）
    6.上下文（当分配到CPU资源时执行，没有资源之后暂时保存自己当前的状态，等待下一次执行，这个过程叫一个上下文）

 程序运行：
    并发：只有一个资源，轮流执行就叫并发
    并行：所有的应用一起运行
无论是从宏观还是从微观的层面都是一起执行的
多个进程不能共享资源
线程是系统调度资源的最小单位
线程是进程执行的最小单位，也是进程执行的实际单位

进程是系统分配资源的最小单位，线程是系统调度的最小单位

进程不可以共享资源，而线程可以
线程可以共享的资源
    1.打开的文件
    2.内存（对象）

线程不可以共享的资源
	上下文  记账信息  状态不能共享  线程栈信息  优先级

注意：线程的数量并不是越多越好，当线程的数量达到某个合适的值是最好的，有太多的线程就会出现线程之间的争抢cpu，
而CPU调度是需要消耗系统资源的，所以不是越多越好。

那么多少线程是最好的？
答：要看具体的应用场景，密集的CPU任务，IO型任务。当使用的场景是计算型任务时，线程的数量=CPU的数量是最好的
	IO型任务理论上线程数量越多越好

进程  VS   线程
1.进程是系统分配资源的最小单位，线程是系统调度的最小单位
2.一个进程中至少要包含一个线程
3.线程必须要依附于进程，线程是进程实质工作调度的最小单位

线程分类：1.后台线程【守护线程】  2.用户线程【默认线程】
守护线程是用来服务用户线程，没有用户线程运行进程就会结束

守护线程使用场景：Java垃圾回收器
注意事项：1.守护线程设置必须在调用start（）前，如果在之后设置不会生效，还会报错
	2.在守护线程里面创建的线程，默认情况全都是守护线程

start 和 run之间的区别：
	1.run属于普通方法，而start属于启动线程的方法
	2.run方法可以执行多次，而start只能执行一次

线程中断：
    1.使用全局自定义的变量来终止线程（在拿到终止指令之后，需要执行完当前的任务才会真正的停止线程）
    2.使用线程提供的终止方法 interrupt来终止线程

interrupted()   和  isInterruped() 
interrupted() 判断当前线程的中断标志位是否设置，调用后清除标志位
 isInterruped() 判断对象关联的线程的标志位是否设置，调用后不清除标志位

线程非安全：
	1.cpu抢占执行
	2.非原子性
	3.编译器优化（代码优化，在单线程下没问题，但在多线程下就会出现混乱）
	4.内存不可见性
	5.多个线程修改了同一个变量
解决线程安全的方案：
	1.synchronized
	2.lock
volatile的作用：
	1.禁止指令重排序
	2.解决内存不可见性的问题（实现原理：当操作完变量后，强制删除线程工作内存中的此变量）
synchronized注意事项：
在进行枷锁操作的时候，同一组业务一定是同一个锁对象
volatile和synchronized的区别：
   volatile可以解决内存可见性问题和禁止指令重排，但不能解决原子性问题
   synchronized是用来保证线程安全，也就是可以解决任何关于线程安全的问题
（关键代码排队执行，始终只有一个线程会执行加锁、原子性问题、。。。。）
synchronized和lock的区别：
  1.synchronized既可以修饰代码块又可以修饰静态方法或普通方法，而lock只能修饰代码块
  2.synchronized只有非公平锁的锁策略，而lock既可以是非公平锁的锁策略也可使是公平锁的锁策略
  3.Reentrantlock更加的灵活
  4.synchronized是自动加锁和释放锁的，而lock需要自己手动加锁和释放锁
synchronized实现的原理：
  从操作系统来说：互斥锁
  从JVM来说：帮我们实现了监视器的加锁和解锁操作
  从JAVA来说：锁对象 锁存放在变量的对象头
synchronized的优化：（四种状态）
  无锁、偏向锁、轻量级锁、重量级锁
线程的状态：
	new（新建状态）
	runnable（执行状态）{running、ready}
	waiting（等待状态）
	timed-waiting（超时等待状态）有明确结束等待时间的sleep方法
	blocked（阻塞状态）  当拿到锁之后会进入runnable状态
	timinated（终止状态）
死锁：
    定义：在多线程编程中，因为资源抢占而造成线程无限等待
造成死锁的四个条件（同时满足）：
    1.互斥条件（一个资源只能被一个线程持有）
    2.请求拥有条件（当拥有有一个资源之后试图请求另外一个资源）
    3.不可剥夺条件（一个资源在被线程拥有之后，不能被其他线程剥夺）
    4.环路等待条件（多个线程在获取资源的时候形成了一个环形链）
解决死锁可以通过修改请求的顺序

线程的通讯机制：一个线程的动作可以让另外一个线程感知到
    wait（休眠）/notify（唤醒）/notifyall（唤醒全部）
wait为什么要加锁？
    答：wait在使用的时候需要释放锁，释放之前必须有一把锁
wait为什么要释放锁？
    答：wait默认是不传值的，当不传递任何值的时候表示永久等待，这样会造成一把锁被一个线程一直持有
 wait（休眠）/notify（唤醒）/notifyall（唤醒全部）使用注意事项：
    1.使用时必须加锁
    2.加锁对象和 wait/notify/notifyall的对象必须保持一致
    3.一组wait/notify/notifyall的对象必须保持一致
Thread.sleep(0) 和 wait(0)的区别
    1.sleep他是Thread的静态方法，而wait是object的方法
    2.sleep(0)立即触发一次CPU的资源抢占，wait(0)则永久等待下去
wait和sleep的区别
相同点：1.都可以让当前线程休眠
              2.都必须要处理一个Interrupt异常
不同点：1.wait来自object中的一个方法，而sleep来自thread
	2.传参不同，wait可以没有参数而sleep必须有一个大于0的参数
	3.wait使用时必须加锁，sleep使用时不用加锁
	4.wait使用时会释放锁，而sleep不会释放
	5.wait默认不传参的情况会进入waiting状态，而sleep会进入timed-waiting
为什么wait放在object而不是Thread中
答：wait必须要加锁和释放锁，而锁是属于对象级别的而非线程级别
（线程和锁是一对多的关系，也就是一个线程可以拥有多把锁）
  为了灵活起见，就把wait放在object当中

Locksupport.park()  也可以进行线程休眠
LockSupport.unpark(线程名);    唤醒

Locksupport.park() 和lock.wait()的区别
    相同点：1.都可以休眠
	2.都可以传参或者不传参，并且二者的线程状态也是一样的
    不同点：1.wait必须加锁，而Locksupport.park不需要加锁
	2.wait只能唤醒全部或随机的一个线程，而Locksupport.park可以唤醒指定的线程
面试题：创建单个线程池有什么作用？
1.可以避免频繁创建和消耗线程带来的性能开销
2.有任务队列可以存储多余的任务
3.当有大量任务不能处理的时候，可以友好的执行拒绝策略
4.线程池可以更好的管理任务
线程池有两个重要的对象：
      线程
      工作队列（integer的最大值）
Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；

Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；

Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；

Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池；

Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；

Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）

ThreadPoolExecutor：最原始的创建线程池的方式

线程池的优点：
  1.避免频繁创建和消耗所带来的性能开销
  2.可以优化的拒绝任务
  3.更多的功能，可以执行定时任务
线程池的六种创建方式：
  1.创建固定的线程池（任务数去向无限大）
  2.创建带缓存的线程池（根据任务的数量生成对应的线程数，适用于短期大量任务）
  3.创建可以执行定时任务的线程池
  4.创建单个可执行的定时任务的线程池
  5.创建单个线程池（a.频繁的创建和消耗  b.更好的分配和执行任务，可以将任务存放到任务队列）
  6.根据当前的工作环境（cpu、任务量）生成对应的线程池；

线程池的拒绝策略：（jdk四种+自定义一种）
  1.默认的拒绝策略
  2.使用调用线程池的线程来执行任务
  3.忽略新任务
  4.忽略老任务
  5.自定义策略
**线程池的两种执行方式：**

 1. execute 执行（new Runnable） 无返回值的任务，如果有OOM异常会将异常打印到控制台；
 2. submit执行（new Runnable、new Callable） 有返回值的任务，如果有OOM异常不会把异常信息打印到控制台；



**线程池的关闭：**

 1. shutdown：拒绝新任务加入，等待线程池中的任务队列执行完毕之后再停止线程；
 2. shutdownNow：拒绝执行新任务，不会等待任务队列中的任务执行完成，直接关闭

**线程池的五种状态：**

 1. RUNNING （线程池创建之后的初始状态）
 2. SHUTDOWN（该状态线程池不再接收新的任务，但是会将工作队列中的任务执行结束）
 3. STOP（该状态线程池不再接收新的任务，但是不会处理工作队列中的任务，立即中断任务）
 4. TIDYING（当线程池空时会进入该状态）
 5. TERMINATED(销毁状态)

**线程池的两种执行方式：**

 1. execute 执行（new Runnable） 无返回值的任务，如果有OOM异常会将异常打印到控制台；
 2. submit执行（new Runnable、new Callable） 有返回值的任务，如果有OOM异常不会把异常信息打印到控制台；



**线程池的关闭：**

 1. shutdown：拒绝新任务加入，等待线程池中的任务队列执行完毕之后再停止线程；
 2. shutdownNow：拒绝执行新任务，不会等待任务队列中的任务执行完成，直接关闭

**线程池的五种状态：**

 1. RUNNING （线程池创建之后的初始状态）
 2. SHUTDOWN（该状态线程池不再接收新的任务，但是会将工作队列中的任务执行结束）
 3. STOP（该状态线程池不再接收新的任务，但是不会处理工作队列中的任务，立即中断任务）
 4. TIDYING（当线程池空时会进入该状态）
 5. TERMINATED(销毁状态)

解决线程不安全的问题
  1.加锁（同时带来了排队执行的问题）
  2.使用ThreadLocal（线程级别的私有变量）
ThreadLocal的使用：
  1.set():将变量放到线程中
  2.get()：从线程中取得私有变量
  3.remove()：从线程中移除私有变量