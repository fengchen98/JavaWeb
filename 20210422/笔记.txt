1.冯诺依曼体系结构
        
        CPU和输入设备或输出设备之间不能直接交互，必须依靠中间的存储部分

内存   VS   硬盘
       1.内存的读写速度远远大于磁盘，内存的读写速度是纳秒级，硬盘的读写速度的是微秒级
       2.内存的价格远大于硬盘
       3.内存中的数据不能持久化，重启之后就没了，而磁盘可以持久化
进程：
一个执行的任务就是一个进程
可执行任务！=进程
PID是进程的身份ID，但重启之后PID就变了
进程的本质：
PCB：进程管理模块
    1.PID  主键id，身份标识
    2.状态信息（就绪，运行，阻塞，终止）
    3.优先级
    4.记账信息（防止CPU资源分配不均）
    5.一组指针（需要使用的资源）
    6.上下文（当分配到CPU资源时执行，没有资源之后暂时保存自己当前的状态，等待下一次执行，这个过程叫一个上下文）

 程序运行：
    并发：只有一个资源，轮流执行就叫并发
    并行：所有的应用一起运行
无论是从宏观还是从微观的层面都是一起执行的
多个进程不能共享资源
线程是系统调度资源的最小单位
线程是进程执行的最小单位，也是进程执行的实际单位

进程是系统分配资源的最小单位，线程是系统调度的最小单位

进程不可以共享资源，而线程可以
线程可以共享的资源
    1.打开的文件
    2.内存（对象）

线程不可以共享的资源
	上下文  记账信息  状态不能共享  线程栈信息  优先级

注意：线程的数量并不是越多越好，当线程的数量达到某个合适的值是最好的，有太多的线程就会出现线程之间的争抢cpu，
而CPU调度是需要消耗系统资源的，所以不是越多越好。

那么多少线程是最好的？
答：要看具体的应用场景，密集的CPU任务，IO型任务。当使用的场景是计算型任务时，线程的数量=CPU的数量是最好的
	IO型任务理论上线程数量越多越好

进程  VS   线程
1.进程是系统分配资源的最小单位，线程是系统调度的最小单位
2.一个进程中至少要包含一个线程
3.线程必须要依附于进程，线程是进程实质工作调度的最小单位

线程分类：1.后台线程【守护线程】  2.用户线程【默认线程】
守护线程是用来服务用户线程，没有用户线程运行进程就会结束

守护线程使用场景：Java垃圾回收器
注意事项：1.守护线程设置必须在调用start（）前，如果在之后设置不会生效，还会报错
	2.在守护线程里面创建的线程，默认情况全都是守护线程